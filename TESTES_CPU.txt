#include <iostream>
#include <vector>
#include <cstdint>
#include <iomanip> // Para std::hex e std::setw
#include "cpu.h"
#include "ram.h"
#include "bus.h"

int main() {
    // 1. Mensagem de verificação
    std::cout << "================================================\n";
    std::cout << "--- EXECUTANDO O TEST SUITE COMPLETO DO RISC-V ---\n";
    std::cout << "================================================\n\n";

    // 2. O programa RISC-V de teste
    // CORREÇÃO: Os valores de teste principais (como 10 e 20)
    // agora são armazenados em registradores salvos (s2, s3)
    // para evitar que sejam sobrescritos por a0 (ECALL) ou t0 (temp).

    std::vector<uint32_t> program_test_suite = {
        // --- Teste I-Type ---
        // 0x00A00513, // addi a0, zero, 10 (RUIM: a0 será sobrescrito)
        0x00A00993, // addi s3, zero, 10           (s3 = 10)
        0x0F09E593, // ori  a1, s3, 0xF0          (a1 = 10 | 240 = 250)
        0x0AA5F613, // andi a2, a1, 0xAA          (a2 = 250 & 170 = 170)
        0x0FF64693, // xori a3, a2, 0xFF          (a3 = 170 ^ 255 = 85)
        
        // --- Teste R-Type ---
        0x00B98733, // add  a4, s3, a1            (a4 = 10 + 250 = 260)
        0x413707B3, // sub  a5, a4, s3            (a5 = 260 - 10 = 250)
        0x00299813, // slli a6, s3, 2             (a6 = 10 << 2 = 40)
        // 0x00185293, // srli t0, a6, 1 (RUIM: t0 será sobrescrito)
        0x00185913, // srli s2, a6, 1             (s2 = 40 >> 1 = 20)

        // --- Teste de Memória (Store) ---
        0x0007F337, // lui  t1, 0x7F             (t1 = 0x7F000)
        0xF0030313, // addi t1, t1, -256          (t1 = 0x7FF00) -> Endereço base
        0x01332023, // sw   s3, 0(t1)             (Salva s3=10 em 0x7FF00)
        0x00B31223, // sh   a1, 4(t1)             (Salva a1=250 em 0x7FF04)
        0x00D30323, // sb   a3, 6(t1)             (Salva a3=85  em 0x7FF06)

        // --- Limpa registradores para teste de Load ---
        0x00000E13, // addi t3, zero, 0           (t3 = 0)
        0x00000E93, // addi t4, zero, 0           (t4 = 0)
        0x00000F13, // addi t5, zero, 0           (t5 = 0)

        // --- Teste de Memória (Load) ---
        0x00032E03, // lw   t3, 0(t1)             (t3 deve ser 10)
        0x00435E83, // lhu  t4, 4(t1)             (t4 deve ser 250)
        0x00634F03, // lbu  t5, 6(t1)             (t5 deve ser 85)

        // --- Teste de Periféricos (VRAM e Console) ---
        // Escreve "Hi" na VRAM (0x80000)
        0x00080337, // lui  t1, 0x80             (t1 = 0x80000)
        0x04800293, // addi t0, zero, 72          (t0 = 'H')
        0x00530023, // sb   t0, 0(t1)             (VRAM[0] = 'H')
        0x06900293, // addi t0, zero, 105         (t0 = 'i')
        0x005300A3, // sb   t0, 1(t1)             (VRAM[1] = 'i')

        // Escreve "!" no Console (0x9FC00)
        // 0x009FC337, // lui  t1, 0x9FC         (ERRO: Carrega 0x9FC000)
        
        // CORREÇÃO: Carrega 0xA0000 e subtrai 1024 (0x400)
        0x000A0337, // lui  t1, 0xA0             (t1 = 0xA0000)
        0xC0030313, // addi t1, t1, -1024         (t1 = 0x9FC00)
        
        0x02100293, // addi t0, zero, 33          (t0 = '!')
        0x00530023, // sb   t0, 0(t1)             (Console <- '!')

        // --- Teste de Branch ---
        // Se t3 (10) == s3 (10), pula o marcador de falha
        0x013EF463, // beq  t3, s3, SKIP_FAIL1   (t3=10, s3=10 -> Deve pular)
        0x06300993, // addi s3, zero, 99          (FALHA 1: s3 = 99)
        0x00000013, // SKIP_FAIL1: nop
        
        // Se a1 (250) != t4 (250), pula o marcador de falha
        0x01FB1463, // bne  a1, t4, SKIP_FAIL2   (a1=250, t4=250 -> Não deve pular)
        0x06300593, // addi a1, zero, 99          (FALHA 2: a1 = 99)
        0x00000013, // SKIP_FAIL2: nop            (a1 deve ser 99 se falhar)

        // --- Teste JAL ---
        0x008000EF, // jal  ra, END_TEST          (Pula o marcador de falha)
        0x06300613, // addi a2, zero, 99          (FALHA 3: a2 = 99)
        0x00000013, // END_TEST: nop

        // --- Teste ECALL (Sleep) ---
        0x05000513, // addi a0, zero, 80          (Código 80 para sleep)
        0x00000073, // ecall
        
        // --- Teste ECALL (Exit) ---
        0x00000513, // addi a0, zero, 0           (Código 0 para sair)
        0x00000073  // ecall
    };

    // 3. Inicializa o hardware
    CPU cpu;
    MainRAM ram;
    VRAM vram;
    Peripherals peripherals;
    Bus bus(&ram, &vram, &peripherals);

    // 4. Carrega o programa
    ram.loadProgram(program_test_suite);

    // 5. Executa
    std::cout << "---[ INÍCIO DA EXECUÇÃO RISC-V ]---\n";
    while (cpu.running) {
        uint32_t instr = cpu.fetch(bus);
        cpu.execute(instr, bus);
    }
    std::cout << "---[ FIM DA EXECUÇÃO RISC-V ]---\n\n";

    // 6. Mostra o resultado
    std::cout << "--- VERIFICAÇÃO PÓS-EXECUÇÃO ---\n";
    
    // Verifica a VRAM (deve mostrar "Hi")
    vram.dumpASCIIToTerminal();
    
    // Mostra todos os registradores
    cpu.print_registers();

    // 7. Verificação automatizada dos resultados
    std::cout << "\n--- VERIFICAÇÃO DE REGISTRADORES CHAVE ---\n";
    
    bool success = true;
    auto check = [&](const char* name, int reg_idx, uint32_t expected) {
        std::cout << "Verificando " << std::setw(5) << name << " (x" << reg_idx << "): ";
        if (cpu.regs[reg_idx] == expected) {
            std::cout << "SUCESSO (Valor: " << cpu.regs[reg_idx] << ")\n";
        } else {
            std::cout << "FALHA! (Valor: " << cpu.regs[reg_idx] << ", Esperado: " << expected << ")\n";
            success = false;
        }
    };

    // Testes I-Type e R-Type (Agora usando s2 e s3)
    check("s3 (I-Type)", 19, 10);  // <-- CORRIGIDO (Usa s3 (x19))
    check("a1 (Branch BNE)", 11, 99);
    check("a2 (I-Type)", 12, 170);
    check("a3 (I-Type)", 13, 85);
    check("a4 (R-Type)", 14, 260);
    check("a5 (R-Type)", 15, 250);
    check("a6 (R-Type)", 16, 40);
    check("s2 (R-Type)", 18, 20);  // <-- CORRIGIDO (Usa s2 (x18))

    // Testes de Load
    check("t3 (Load LW)",  28, 10);
    check("t4 (Load LHU)", 29, 250);
    check("t5 (Load LBU)", 30, 85);

    // Teste ECALL (a0 é usado como arg, então deve ser 0 da última chamada)
    check("a0 (ECALL arg)", 10, 0); // <-- CORRIGIDO (Este teste agora está correto)


    std::cout << "\n========================================\n";
    if (success) {
        std::cout << ">>> SUCESSO! O TEST SUITE FOI CONCLUÍDO SEM ERROS.\n";
    } else {
        std::cout << ">>> FALHA! UM OU MAIS TESTES FALHARAM.\n";
    }
    std::cout << "========================================\n";

    return 0;
}